from unicodedata import normalize, name

s1 ='café'
s2 = 'cafe\N{COMBINING ACUTE ACCENT}'
# Unicode-эскейп-последовательностью в Python,
# которая используется для представления символа в кодировке Unicode.
# В данном случае, эта последовательность соответствует символу "комбинирующий знак острого ударения (Combining Acute Accent)", 
# который может быть добавлен к другому символу для обозначения ударения в некоторых языках.
# Например, если мы хотели бы отобразить символ "é" с помощью Unicode-эскейп-последовательности,
# мы бы могли написать: '\u00e9', а если мы хотели бы добавить к символу "e" комбинирующий знак острого ударения,
# то мы могли бы написать: 'e\N{COMBINING ACUTE ACCENT}'.
print(len(s1),len(s2))


# normalize() используется для нормализации строк в заданном формате Unicode
# (в данном случае - NFC). NFC (Normalization Form C) - это форма нормализации,
# которая приводит декомпозированные символы с комбинирующими знаками (например, буква "é" и комбинирующий знак острого ударения)
# к эквивалентной составной форме (кодировке) символов (в данном примере, единственный символ '\u00e9').
# Таким образом, если переменная s1 содержит строку в Unicode с декомпозированными символами,
# то len(normalize('NFC',s1)) вернет длину этой строки после нормализации в формате NFC.
print(
    len(normalize('NFC',s1)),len(normalize('NFC',s2))
    )
print(
    len(normalize('NFD',s1)),len(normalize('NFD',s2))
    )

half = '\N{VULGAR FRACTION ONE HALF}'
print(half)
print(normalize('NFKC', half))

for char in normalize('NFKC', half):
    print(char,name(char), sep='\t')
# (Normalization Form Compatibility Decomposition) - это форма нормализации,
# которая приводит символы к их совместимой декомпозиции (Compatibility Decomposition)
# и затем к обратной композиции (Composition).
# В данном случае, так как символ "одна половина" имеет совместимую декомпозицию,
# он будет приведен к эквивалентному символу "одна половина" (½)

# Формы нормализации NFKC и NFKD следует применять с осторожностью и только в особых случаях,
# например для поиска и индексирования, а не для постоянного хранения текста,
# поскольку выполняемые ими преобразования могут приводить к потере данных.
