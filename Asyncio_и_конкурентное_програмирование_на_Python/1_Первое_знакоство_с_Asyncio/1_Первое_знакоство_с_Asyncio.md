 

## Основные понятия:

### Конкурентность в Python:

Можно сравнить с ситуацией в кафе, где несколько официантов (потоков) обслуживают несколько посетителей (задач) одновременно.

Представьте, что вы посещаете кафе, где есть несколько официантов и несколько посетителей. Каждый официант обслуживает одного посетителя за раз. Если один официант занят, другие могут принимать заказы и обслуживать других посетителей параллельно. Таким образом, работа кафе становится более эффективной, поскольку несколько официантов могут обслуживать несколько посетителей одновременно.

### Параллелизм в Python:

Можно сравнить с подготовкой завтрака. Когда вы готовите завтрак, вы можете одновременно готовить яичницу на сковороде, заваривать кофе и жарить бекон в духовке. Каждая из этих задач выполняется параллельно, что позволяет вам получить готовый завтрак быстрее, чем если бы вы делали все по очереди. Точно так же в Python параллелизм позволяет выполнять несколько задач одновременно, улучшая производительность программы.

### Поток в Python:

Аналогия: Поток в Python подобен дорожному движению на дороге. Каждый поток представляет собой отдельное транспортное средство, которое может двигаться независимо от других. Водители (или потоки) могут двигаться параллельно, обгонять друг друга или останавливаться, чтобы выполнить определенное действие. Подобно тому, как дороги могут иметь разные полосы для обеспечения параллельного движения нескольких машин, потоки в Python могут выполняться параллельно для увеличения эффективности и скорости выполнения программы.

### Процесс и поток - это два различных понятия, хотя и связанные между собой:

1. **Процесс (Process):**
    - Процесс представляет собой независимый запущенный экземпляр программы на компьютере.
    - Каждый процесс имеет своё собственное пространство памяти и ресурсы, которые он использует для выполнения задачи.
    - Процессы обычно создаются операционной системой при запуске программы.
    - Процессы могут взаимодействовать между собой через механизмы межпроцессного взаимодействия (IPC).
    - Создание процесса требует больше системных ресурсов, чем создание потока.
2. **Поток (Thread):**

    - Поток представляет собой легковесный процесс, который существует внутри процесса.
    - Все потоки внутри одного процесса используют общее пространство памяти и ресурсы процесса.
    - Потоки внутри одного процесса могут выполняться параллельно (если имеется несколько ядер процессора) или конкурентно (путём многозадачности временного деления).
    - Потоки обычно используются для выполнения параллельных задач или для обработки ввода-вывода, который может блокировать выполнение программы.
    - Создание и уничтожение потоков обычно менее затратно по сравнению с процессами.
### GIL в Python

1. Аналогия: GIL (Global Interpreter Lock) в Python подобен ситуации, когда только один человек имеет ключ от сейфа и может работать с ним в определенный момент времени. Другие должны ждать своей очереди.
    
2. Короткое объяснение: GIL - это механизм в Python, который обеспечивает, что только один поток исполнения может выполнять байт-код Python в определенный момент времени. Это может ограничивать параллельную обработку в многозадачных приложениях.
### Когда GIL в Python освобождается?
когда процесс выполняет операции ввода-вывода, блокирующие операции или когда используются многопоточные библиотеки, которые обходят GIL. Для достижения асинхронности в Python используются асинхронные библиотеки и ключевое слово `asyncio`.
#### Сокеты

1. Аналогия: Сокеты, подобно телефонным линиям, которые позволяют разным устройствам общаться между собой. Как телефонные разъемы, сокеты определяют, как данные будут передаваться между устройствами.
    
2. Короткое объяснение: Сокеты - это программный интерфейс, который позволяет взаимодействовать между процессами на разных устройствах через сеть. Они определяют точку соединения для обмена данными.
``` Python
Простой TCP-сервер:
import socket

# Создание TCP сокета
server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)

# Привязка сокета к адресу и порту
server_socket.bind(('localhost', 12345))

# Ожидание соединения
server_socket.listen(5)

while True:
    # Принятие входящего соединения
    client_socket, address = server_socket.accept()
    print(f"Connection from {address} has been established!")

    # Отправка данных клиенту
    client_socket.send(b"Hello from the server!")

    # Закрытие соединения с клиентом
    client_socket.close()

Простой TCP-клиент:
import socket

# Создание TCP сокета
client_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)

# Подключение к серверу
client_socket.connect(('localhost', 12345))

# Получение данных от сервера
data = client_socket.recv(1024)
print("Received:", data.decode())

# Закрытие соединения с сервером
client_socket.close()


```
По умолчанию сокеты блокирующие, но операционная система может их переводить в неблокирующий режим. И как раз библиотека asyncio передает управление операционной системе и уведомление центру сообщений, что сокет ответил. Для управления этими задачами используется цикл событий.
### Цикл событий
Это механизм, который обрабатывает события и вызывает соответствующие обработчики в процессе выполнения программы, обеспечивая асинхронное выполнение задач
 

## Короткая суть главы:
В Питоне есть асинхронность, но она проявляется в основном при вводе и выводе, так как GIL блокирует выполнение многопоточности на уровне одного байт-кода Python из-за конфликта за ресурсы памяти. В таких случаях можно использовать сокеты, которыми управляет операционная система, и которые сообщают, если произошло что-то неожиданное, а также предоставляют возможность получить ответ. С помощью всех этих средств можно реализовать паттерн программирования "Цикл событий"